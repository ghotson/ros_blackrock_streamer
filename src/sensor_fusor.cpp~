#include "harmonie_movement_primitives/neural_features.h"
#include "DMPS.h"
#include "sensor_fusor.h"

#include <vector>
#include <string>
#include <Eigen/Cholesky>
#include <Eigen/Dense>
#include <fstream>
#include <sstream>
#include <iostream>

double bytesToDouble(BYTE *bytes, int *index)
{
  double result = 0;
  memcpy(&result,bytes+*index,8);
  *index += SIZE_DOUBLE;
  return result;
}

int bytesToInt(BYTE *bytes,int *index)
{
  int result = 0;
  memcpy(&result,bytes+*index,4);
  *index += SIZE_INT;
  return result;
}


//constructor
SensorFusor::SensorFusor()
{
  // -------ROS Initialization stuff----------

  //prediction_client = n_.serviceClient<harmonie_movement_primitives::Predict>("predict");

  measurement_sub = n_.subscribe("measurement", 1000, &SensorFusor::measurementCallback, this);

  //prediction_ready_sub = n_.subscribe<std_msgs::Bool>("predict_ready", 1000,  &SensorFusor::predictionCallback, this);

  // ---------UKF Initialization stuff
  
  // check matlab code for what was used for these values
  double alpha = 1;
  double kappa = 1;
  double beta = 1;

  unsigned int num_sigma_points = STATE_SIZE*2+1;
  sigma_points_.resize(num_sigma_points, Eigen::VectorXd(STATE_SIZE));
  state_weights_.resize(num_sigma_points);
  cov_weights_.resize(num_sigma_points);

  state_weights_[0] = lambda_ / (STATE_SIZE + lambda_);
  cov_weights_[0] = state_weights_[0] + (1 - (alpha*alpha) + beta);
  sigma_points_[0].setZero();

  for(size_t i = 1; i < num_sigma_points; ++i)
  {
    sigma_points_[i].setZero();
    state_weights_[i] =  1 / (2 * (STATE_SIZE + lambda_));
    cov_weights_[i] = state_weights_[i];
  }

  // first 3 = xyz positions, then velocities, then acc 
  state_.setZero();
  error_covariance_estimate_.Identity();

  loadSensorFusorParams();
}

void SensorFusor::loadSensorFusorParams(std::string file_name)
{
  //open the file
  std::streampos file_size;
  std::ifstream file(file_name.data(),std::ios::binary);

  // get file size
  file.seekg(0, std::ios::end);
  file_size = file.tellg();
  file.seekg(0, std::ios::beg);

  // read the data
  BYTE file_data[(int)file_size];
  file.read((char*) &file_data[0], file_size);

  // parse the data (format in google drive)
  int index = 0;

  // goes colwise
  for (int ii=0; ii<STATE_SIZE; ii++)
    for (int jj=0; jj<STATE_SIZE; jj++)
      process_noise_covariance_(jj,ii) = bytesToDouble(file_data,&index);

  num_features_ = bytesToInt(file_data,&index);

  measurement_mapping_.resize(num_features_,STATE_SIZE);
  for (int ii=0; ii<STATE_SIZE; ii++)
    for (int jj=0; jj<num_features_; jj++)
      measurement_mapping_(jj,ii) = bytesToDouble(file_data,&index);

  measurement_noise_covariance_.resize(num_features_,STATE_SIZE);
  for (int ii=0; ii<num_features_; ii++)
    for (int jj=0; jj<num_features_; jj++)
      measurement_noise_covariance_(jj,ii) = bytesToDouble(file_data,&index);
}

//void SensorFusor::measurementCallback(const harmonie_movement_primitives::measurement::ConstPtr& msg)
void SensorFusor::measurementCallback(const harmonie_movement_primitives::neural_features::ConstPtr& msg)
{
  //Eigen::Map<Eigen::VectorXd> neural_features(msg->data.data(),num_features_); 
  if (msg->data.size() != num_features_)
    ROS_ERROR("num_features_ and msg size disagree!!!");

  Eigen::VectorXd neural_features;
  neural_features.resize(num_features_,1);
  for (int ii=0; ii<num_features_; ii++)
    neural_features(ii) = msg->data[ii];

  // Do Kalman filter update for measurement
  // get residual
  Eigen::VectorXd measurement_residual = neural_features - measurement_mapping_*state_;

  // get residuals covariance
  Eigen::MatrixXd measurement_residual_cov = measurement_mapping_*measurement_residual_cov*measurement_mapping_.transpose() + measurement_noise_covariance_;

  // kalman gain
  Eigen::MatrixXd kalman_gain = error_covariance_estimate_*measurement_mapping_*measurement_residual_cov.inverse();

  // update state estimate
  state_ += kalman_gain*measurement_residual;

  // update covariance estimate
  Eigen::MatrixXd eye = Eigen::MatrixXd::Identity(STATE_SIZE,STATE_SIZE);
  error_covariance_estimate_ = (eye - kalman_gain*measurement_mapping_)*error_covariance_estimate_;
}

void SensorFusor::update(Eigen::VectorXd neural_features)
{
  // Do Kalman filter update for measurement
  // get residual
  Eigen::VectorXd measurement_residual = neural_features - measurement_mapping_*state_;

  // get residuals covariance
  Eigen::MatrixXd measurement_residual_cov = measurement_mapping_*measurement_residual_cov*measurement_mapping_.transpose() + measurement_noise_covariance_;

  // kalman gain
  Eigen::MatrixXd kalman_gain = error_covariance_estimate_*measurement_mapping_*measurement_residual_cov.inverse();

  // update state estimate
  state_ += kalman_gain*measurement_residual;

  // update covariance estimate
  Eigen::MatrixXd eye = Eigen::MatrixXd::Identity(STATE_SIZE,STATE_SIZE);
  error_covariance_estimate_ = (eye - kalman_gain*measurement_mapping_)*error_covariance_estimate_;

}

//void SensorFusor::predictionCallback(const std_msgs::Bool::ConstPtr& msg)
void SensorFusor::predict()
{
  // uses the unscented transform to estimate the covariance

  
  // (1) Take the square root of a small fraction of the estimateErrorCovariance_ using LL' decomposition
  weighted_cov_sqrt_ = ((STATE_SIZE + lambda_) * error_covariance_estimate_).llt().matrixL();
  //ROS_INFO("weighted_cov_sqrt_: %f",weighted_cov_sqrt_(0));

  // (2) Compute sigma points and pass them through the DMPs without progressing time
  bool b_progress_time = false;

  // initialize the sigma point vectors
  for (int ii=0; ii<STATE_SIZE*2+1; ii++)
    sigma_points_[ii].resize(STATE_SIZE,1);

  for (int sigma_ind=0; sigma_ind<STATE_SIZE; sigma_ind++)
  {
    //sigma_points_[sigma_ind + 1] = transferFunction_ * (state_ + weightedCovarSqrt_.col(sigma_ind));
    dmps_.setKinematics(state_ + weighted_cov_sqrt_.col(sigma_ind));
    std::vector<double> temp = dmps_.run(b_progress_time); // doesn't seem like it's not progressing time!!
    for (int ii=0; ii<STATE_SIZE; ii++)
      sigma_points_[sigma_ind + 1](ii) = temp[ii];

    //sigma_points_[sigma_ind + 1 + STATE_SIZE] = transferFunction_ * (state_ - weightedCovarSqrt_.col(sigma_ind));
    dmps_.setKinematics(state_ - weighted_cov_sqrt_.col(sigma_ind));
    temp = dmps_.run(b_progress_time); // doesn't seem like it's not progressing time!!
    for (int ii=0; ii<STATE_SIZE; ii++)
      sigma_points_[sigma_ind + 1 + STATE_SIZE](ii) = temp[ii];

  }

  
  // now pass through the mean and progress time
  b_progress_time = 1;
  dmps_.setKinematics(state_);
  std::vector<double> temp = dmps_.run(b_progress_time); 
  for (int ii=0; ii<STATE_SIZE; ii++)
    sigma_points_[0](ii) = temp[ii];

  // (3) calculate the weighted mean and covariance given the transformed sigma points
  state_.setZero();
  for (int ii=0; ii<sigma_points_.size(); ii++)
    state_.noalias() += state_weights_[ii] * sigma_points_[ii];
  state_.noalias() = sigma_points_[0];

  // (4) Now use the sigma points and the predicted state to compute a predicted covariance
  error_covariance_estimate_.setZero();
  Eigen::VectorXd sigma_diff(STATE_SIZE);
  for(size_t sigma_ind = 0; sigma_ind < sigma_points_.size(); ++sigma_ind)
  {
    sigma_diff = (sigma_points_[sigma_ind] - state_);
    error_covariance_estimate_.noalias() += cov_weights_[sigma_ind] * (sigma_diff * sigma_diff.transpose());
  }

  // (5) add the process noise
  error_covariance_estimate_.noalias() += process_noise_covariance_;

}
