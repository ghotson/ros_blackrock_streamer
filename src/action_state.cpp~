#include "ros/ros.h"
#include "std_msgs/UInt32.h"
#include "std_msgs/Float64.h"
#include "harmonie_movement_primitives/neural_features.h"
#include "action_state.h"

#include <Eigen/Dense>
#include <string>
#include <sstream>
#include <fstream>
#include <vector>
#include <cmath>
#include <iostream>

typedef unsigned char BYTE;
#define SIZE_INT 4
#define SIZE_DOUBLE 8

double bytesToDouble(BYTE *bytes, int *index)
{
  double result = 0;
  memcpy(&result,bytes+*index,8);
  *index += SIZE_DOUBLE;
  return result;
}

int bytesToInt(BYTE *bytes,int *index)
{
  int result = 0;
  memcpy(&result,bytes+*index,4);
  *index += SIZE_INT;
  return result;
}

//
void ActionState::loadActionCoeffs(const char *fileName)
{
  //if(sizeof(double) != SIZE_DOUBLE || sizeof(int) != SIZE_INT)
   // ROS_ERROR("double or int isn't sized correctly for parsing");

  // open the file:
  std::streampos fileSize;
  std::ifstream file(fileName, std::ios::binary);

  // get its size:
  file.seekg(0, std::ios::end);
  fileSize = file.tellg();
  file.seekg(0, std::ios::beg);

  // read the data:
  BYTE fileData[(int)fileSize];
  file.read((char*) &fileData[0], fileSize);

  // parse the data (format found in google drive doc)
  int index = 0;

  num_states_ = bytesToInt(fileData,&index);
  //ROS_INFO("num_states_: %d",num_states);
  //printf("num_states_: %d\n",num_states_);

  // read in the state transition matrix
  transition_mat_.resize(num_states_,num_states_);
  // goes colwise
  for (int ii=0; ii<num_states_; ii++)
    for (int jj=0; jj<num_states_; jj++)
      transition_mat_(jj,ii) = bytesToDouble(fileData,&index);

  //ToDo: read in the state priors
  state_priors_.resize(num_states_);
  state_priors_.fill(1.0f / num_states_);
  state_probs_neural_.resize(num_states_);
  state_probs_.resize(num_states_);

  num_features_ = bytesToInt(fileData,&index);

  // read in the mean and std for each of the features
  feature_means_.resize(num_states_,num_features_);
  feature_stds_.resize(num_states_,num_features_);
  ROS_INFO("num_features_: %d\n",num_features_);
  for (int ii=0; ii<num_states_; ii++)
  {
    for (int jj=0; jj<num_features_; jj++)
    {
      feature_means_(ii,jj) = bytesToDouble(fileData,&index);
      feature_stds_(ii,jj) = bytesToDouble(fileData,&index);
    } 
  }
  ROS_INFO("last feature_mean: %f\n",feature_means_(num_states_-1,num_features_-1));
}

//constructor
ActionState::ActionState(const char* fileName)
{
  loadActionCoeffs(fileName);

  pub_ = n_.advertise<std_msgs::UInt32>("action",1000);
  feature_sub_ = n_.subscribe("features",1,&ActionState::featureCallback,this);
  obj_sub_ = n_.subscribe("object",1,&ActionState::objCallback,this);
}


template <typename T>
T normal_pdf(T x, T mean, T std)
{
  static const T inv_sqrt_2pi = 0.3989422804014327; 
  T a = (x - mean) / std;

  return inv_sqrt_2pi / std * std::exp(-0.5*a*a);
}


void ActionState::updateNeuralProbs(Matrix<double, Dynamic, 1> neural_features)
{ 
  state_probs_neural_.fill(1); //initialize to 1
  for (int ii=0; ii<num_states_; ii++)
  {
    for (int jj=0; jj<num_features_; jj++)
    {
      state_probs_neural_(ii) *= normal_pdf(neural_features(jj),
			 feature_means_(ii,jj),
			 feature_stds_(ii,jj));
    }
  }
    
}

void ActionState::update(Matrix<double, Dynamic, 1> neural_features)
//void ActionState::update(const double *neural_features)
{
  updateNeuralProbs(neural_features);
  Matrix<double, Dynamic, 1> prev_state_probs_;
  prev_state_probs_ << state_probs_;

  for (int ii=0; ii<num_states_; ii++) //loop through the current states
  {
    //Matrix<double,1,1> sum;
    double sum = 0;
    for (int jj=0; jj<num_states_; jj++) //loop through the previous states
      sum += transition_mat_(jj,ii)*prev_state_probs_(jj);

    state_probs_(ii) = sum * state_probs_neural_(ii) / state_priors_(ii);
  }
  for (int ii=0; ii<num_states_; ii++) //loop through the current states
    state_probs_(ii) /= state_probs_.sum();
}

// ToDo: change the state transition matrix to be object dependent
void ActionState::updateProbsObj()
{
  
}

// ToDo: create mapping between states and DMPs
int ActionState::getCurrentDMP()
{
  double max = 0;
  int max_index = 0;
  for (int ii=0;ii<num_states_;ii++)
  {
    if (max < state_probs_(ii))
    {
      max = state_probs_(ii);
      max_index = ii;
    }
  }
  return max_index;
}

// callback function for when features are received
void ActionState::featureCallback(const harmonie_movement_primitives::neural_features::ConstPtr& msg)
{
  ROS_INFO("I heard: %f", msg->data[0]);
  Matrix<double, Dynamic, 1> neural_features;
  neural_features.resize(num_features_);
  // ToDo: add check for message size is right, use an eigen map to save memory
  for (int ii=0;ii<num_features_;ii++)
    neural_features(ii) = msg->data[ii];

  update(neural_features);
  updateProbsObj();

  std_msgs::UInt32 current_DMP_msg;
  current_DMP_msg.data = getCurrentDMP();
  pub_.publish(current_DMP_msg); 
}

// callback function for when object type is received
void ActionState::objCallback(const std_msgs::UInt32::ConstPtr& msg)
{
  current_obj_ = msg->data;
  ROS_INFO("setting current_obj_ to %d",msg->data);
}
