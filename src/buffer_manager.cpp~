#include "ros/ros.h"
#include "buffer_manager.h"
#include <stdlib.h>
#include <cstring>
#include <vector>

BufferManager::BufferManager(){}

void BufferManager::initializeBufferManager(unsigned int num_features,// num_features doesn't include tap delays
    unsigned int num_tap_delays,
    std::vector<unsigned int> tap_delays,
    unsigned int feature_window_size)
{
  num_features_ = num_features;
  tap_delays_ = tap_delays;
  feature_window_size_ = feature_window_size;
  num_tap_delays_ = num_tap_delays;
  
  int max = 0;

  for (int ii=0; ii<num_tap_delays; ii++)
  {
    if (max < tap_delays_[ii])
      max = tap_delays_[ii];
  }
  max_tap_delay_ = max;
  
  // how far back the buffer has to go to accomodate all the tap delays
  buffer_length_ = max_tap_delay_+feature_window_size_;

  buffer_.resize(num_features_);
  for (int ii=0; ii<num_features_; ii++)
    buffer_[ii].resize(buffer_length_);

  data_.resize(num_features_*num_tap_delays_);
  for (int ii=0; ii<num_tap_delays_; ii++)
    for (int jj=0; jj<num_features_; jj++)
      data_[jj+ii*num_features_].resize(feature_window_size_);
}

void BufferManager::shiftDataLeft(unsigned int feature_index, unsigned int num_indices)
{
  for (int ii=num_indices; ii<buffer_length_; ii++)
  {
    buffer_[feature_index][ii-num_indices] = buffer_[feature_index][ii];
  }
}

void BufferManager::insertData(std::vector<std::vector<short unsigned int> > data)
{
  for (int ii=0; ii<num_features_; ii++)
  {
    int num_samples = data[ii].size();
    BufferManager::shiftDataLeft(ii,num_samples);
    if (num_samples > buffer_length_)
    {
      for (int jj=0; jj<num_samples; jj++)
      {
        int insertionIndex = num_samples - buffer_length_ + jj;
        buffer_[ii][jj] = data[ii][insertionIndex];
      }
    }
    else
    {
      for (int jj=0; jj<num_samples; jj++)
      {
        int insertionIndex = buffer_length_ - num_samples + jj;
        buffer_[ii][insertionIndex] = data[ii][jj];
//        ROS_INFO("inserted: %d into %d",data[ii][jj],ii);
      }
    }
  }
}

std::vector<std::vector<double> > BufferManager::getData()
{
  // return a vector full of vectors for each tap delay
  for (int ii=0; ii<num_tap_delays_; ii++)
    for (int jj=0; jj<num_features_; jj++)
       data_[jj+ii*num_features_].assign(
           buffer_[jj].data() + max_tap_delay_ - tap_delays_[ii],
           buffer_[jj].data() + max_tap_delay_ - tap_delays_[ii] + feature_window_size_);

  return data_;
}
