#include "ros/ros.h"
#include "std_msgs/String.h"
#include "buffer_manager.h"
#include "harmonie_movement_primitives/blackrock_data.h"
#include "harmonie_movement_primitives/blackrock_channel_data.h"
#include "harmonie_movement_primitives/neural_features.h"
#include "ar_spectra.h"

#include <sstream>
#include <fstream>
#include <string>
#include <iostream>
#include <vector>

typedef unsigned char BYTE;
#define SIZE_INT 4
#define SIZE_DOUBLE 8

double bytesToDouble(BYTE *bytes, int *index)
{
  double result = 0;
  memcpy(&result,bytes+*index,8);
  *index += SIZE_DOUBLE;
  return result;
}

int bytesToInt(BYTE *bytes,int *index)
{
  int result = 0;
  memcpy(&result,bytes+*index,4);
  *index += SIZE_INT;
  return result;
}

class FeatureExtractor
{
  public:
    //constructor
    FeatureExtractor(const char* fileName = "/home/ghotson/Documents/feature_extraction_values", unsigned int feature_window_size = 128);

  private:
    BufferManager buffer_manager_;
    std::vector<unsigned int> keep_channels_;
    std::vector<unsigned int> tap_delays_;
    unsigned int extraction_window_size_, num_freqs_, num_channels_, num_tap_delays_;
    std::vector<std::string> feature_channel_names_;

    ros::NodeHandle n_;
    ros::Publisher pub_;
    ros::Subscriber sub_;

    void loadARValues(BYTE *file_data, int index);
    void callback(const harmonie_movement_primitives::blackrock_data::ConstPtr& msg);

};

FeatureExtractor::FeatureExtractor(const char* fileName, unsigned int feature_window_size)
{
  // open file
  std::streampos fileSize;
  std::ifstream file(fileName, std::ios::binary);

  // get file size
  file.seekg(0, std::ios::end);
  fileSize = file.tellg();
  file.seekg(0, std::ios::beg);

  // read the data
  BYTE file_data[(int)fileSize];
  file.read((char*) &file_data[0], fileSize);

  // now we can start parsing the data!
  int index = 0;

  // first check what feature extraction method we are using
  std::string extraction_method((char *)file_data,3);
  // right now we are only using AR, so we can ignore this
  index += 3;
  
  if (!extraction_method.compare("AR_"))
    loadARValues(file_data,index);
  else
    ROS_ERROR("Only AR_ method currently supported!");

  buffer_manager_.initializeBufferManager(num_channels_, num_tap_delays_, tap_delays_, extraction_window_size_);

  pub_ = n_.advertise<harmonie_movement_primitives::neural_features>("features",1);
  sub_ = n_.subscribe<harmonie_movement_primitives::blackrock_data>("blackrock_data",1,
      &FeatureExtractor::callback,this);
}

void FeatureExtractor::loadARValues(BYTE *file_data, int index)
{
  extraction_window_size_ = bytesToInt(file_data,&index);
  num_freqs_ = bytesToInt(file_data,&index);

  double extraction_freqs[num_freqs]; 
  for (int ii=0; ii<num_freqs_; ii++)
    extraction_freqs[ii] = bytesToDouble(file_data,&index);

  num_tap_delays_ = bytesToInt(file_data,&index);
  tap_delays_.resize(num_tap_delays_);
  for (int ii=0; ii<num_tap_delays_; ii++)
    tap_delays_[ii] = bytesToInt(file_data,&index);

  num_channels_ = bytesToInt(file_data,&index);

  feature_channel_names_.resize(num_channels_);
  
  for (int ii=0; ii<num_channels_; ii++)
  {
    int counter = 0;
    int index_old = index;
    while ((char)file_data[index++] != ',')
    {
      counter++;
    }
    std::string result((char *)file_data+index_old,counter);
    feature_channel_names_[ii] = result;
  }
}

void FeatureExtractor::callback(const harmonie_movement_primitives::blackrock_data::ConstPtr& msg)
{
  int num_channels = sizeof(msg->data)/sizeof(msg->data[0]);

  std::vector<harmonie_movement_primitives::blackrock_channel_data> chan_data = msg->data;
  std::vector<int> num_samples = msg->num_samples;
  std::vector<std::string> channel_labels = msg->channel_labels;

  // map the incoming channels to the feature extraction channels
  // Should only have to do this once?  ToDo, check this!!!
  // Might throw an error, not sure blackrock data is always the same order.
  if (keep_channels_.empty())
  {
    keep_channels_.resize(feature_channel_names_.size());
    // loop through and find the channels that we have to keep
    for (int ii=0; ii<feature_channel_names_.size(); ii++)
    {
      for (int jj=0; jj<channel_labels.size(); jj++)
      {
        if (!feature_channel_names_[ii].compare(channel_labels[jj]))
        {
          keep_channels_[ii] = jj;
          ROS_INFO("matched: %s at %d",feature_channel_names_[ii].c_str(),jj);
          break;
        }
        if (jj == channel_labels.size()-1)
          ROS_ERROR("Didn't find a match for feature channel %s",
              feature_channel_names_[ii].c_str());
      }
    }
  }

  // insert into buffer in appropriate order
  std::vector<std::vector<unsigned short int> >reordered_data;
  reordered_data.resize(num_channels_);
  for (int ii=0; ii<keep_channels_.size(); ii++)
  {
    int size = chan_data[keep_channels_[ii]].channel_data.size();
    reordered_data[ii].resize(size);
    for (int jj=0; jj<size; jj++)
      reordered_data[ii][jj] = chan_data[keep_channels_[ii]].channel_data[jj];
  }
  buffer_manager_.insertData(reordered_data);

  std::vector<std::vector<double> > aligned_data = buffer_manager_.getData();

  // extract the features
  std::vector<double> features(aligned_data.size());
  for (int ii=0; ii<aligned_data.size(); ii++)
  {
    double pxx[num_freqs_];
    features[ii] = arSpectra_HG(aligned_data[ii].data(), extraction_window_size_, pxx);
  }

  // publish the features
  harmonie_movement_primitives::neural_features features_msg;
  features_msg.data = features;
  pub_.publish(features_msg);
}

int main(int argc, char**argv)
{
  //testARBurg();
  ros::init(argc, argv, "features_extractor");

  FeatureExtractor feature_extractor("/home/ghotson/Documents/feature_extraction_values",128);

  ros::spin();
}
